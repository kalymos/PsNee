// *****************************************************************************************************************
// Configuration for different microcontrollers (MCU) to ensure compatibility with the code:
// - Defines the clock speed, timers, and interrupts for each MCU.
// - Configures I/O pins for data, clocks, and switches according to the requirements.
// - Enables pull-up resistors on input pins where needed.
// - Manages external interrupts and LED outputs for system feedback.
// - Ensures the setup is compatible with various microcontroller models (e.g., ATmega328, ATtiny series, etc.)
// *****************************************************************************************************************

//******************************************************************************************************************
// Configuring the clock speed and associated registers. The formula for calculating
// the clock frequency is F_CPU / (TCCR0B |= (1<<CS00)) * (OCR0A = 159 +1) = 16000000 / (0 * (160)) = 100KHz
//******************************************************************************************************************

//******************************************************************************************************************
// Example: DDRB &= ~(1<<DDB0);  // Create a mask by shifting the bit 1 to the left by DDB0's position (bit 0), and then inverting it.
// The bitwise AND operation (&=) updates the register DDRB by clearing the DDB0 bit (setting it to 0)
// without affecting the other bits.
//
// For instance, if DDRB = b11111111 (binary value), the operation shifts the bit 1 to the left to create the mask
// (1<<DDB0) = b00000001, and then inverts it, which results in b11111110. The AND operation with DDRB clears DDB0.
//
// Before:  DDRB = b11111111  // Initial value of DDRB (all pins set as output)
// Mask:    ~(b00000001) = b11111110  // Mask generated by shifting and inverting the bit
// After:   DDRB = b11111110  // The DDB0 bit is cleared (set to 0), while other bits remain unchanged
//******************************************************************************************************************

//******************************************************************************************************************
// Example: DDRB |= (1<<DDB0);  // Create a mask by shifting the bit 1 to the left by DDB0's position (bit 0),
// and then apply a bitwise OR operation to set DDB0 to 1 (configure pin PB0 as an output).
//
// For instance, if DDRB = b11111111 (binary value), the operation shifts the bit 1 to the left to create the mask
// (1<<DDB0) = b00000001. The OR operation with DDRB sets the DDB0 bit to 1, leaving other bits unchanged.
//
// Before:  DDRB = b11111111  // Initial value of DDRB (all pins set as output)
// Mask:    (1<<DDB0) = b00000001  // Mask generated by shifting the bit 1 to the left to position DDB0
// After:   DDRB = b11111111  // The DDB0 bit is set to 1, configuring pin PB0 as an output
//******************************************************************************************************************

//******************************************************************************************************************
// Example: (PIND & (1<<PIND6));  // Create a mask by shifting the bit 1 to the left by PIND6's position (bit 6),
// and then apply a bitwise AND operation to read the state of the PIND6 pin.
// The result will be non-zero (true) if the PIND6 pin is high (1), and zero (false) if the PIND6 pin is low (0).
//
// For instance, if PIND = b10101010 (binary value), the operation shifts the bit 1 to the left to create the mask
// (1<<PIND6) = b01000000. The AND operation between PIND and the mask checks if the 6th bit is set to 1 (high).
//
// Before:  PIND = b10101010  // Initial value of PIND (register containing input pin states)
// Mask:    (1<<PIND6) = b01000000  // Mask generated by shifting the bit 1 to the left to position PIND6
// Operation: PIND & b01000000 = b00000000 // If PIND6 is low (0)
// Operation: PIND & b01000000 = b01000000 // If PIND6 is high (1)
//
//******************************************************************************************************************

//******************************************************************************************************************
// Example: EICRA |= (1<<ISC01) | (1<<ISC00);
// This operation configures the external interrupt sense control (ISC) for interrupt INT0 (External Interrupt Request 0).
// Specifically, it sets the mode of INT0 to "rising edge" trigger, meaning the interrupt will be triggered when the pin
// transitions from low to high (rising edge).
//
// EICRA (External Interrupt Control Register A) controls how external interrupts INT0 and INT1 are triggered.
// The bits ISC01 and ISC00 in this register define the trigger mode for interrupt INT0.
//
// - Setting ISC01 to 1 and ISC00 to 1 (via the OR operation) configures INT0 to trigger on the rising edge.
//
// Before:  EICRA = b00000000  // Initial value of EICRA, all interrupt sense control bits are cleared (no trigger mode set).
// Operation: EICRA |= (1<<ISC01) | (1<<ISC00)  // Set ISC01 and ISC00 to 1 for rising edge trigger.
// After:   EICRA = b00000011  // The bits ISC01 and ISC00 are now set, configuring INT0 to trigger on rising edge.
//
// This technique is commonly used to configure external interrupts to trigger based on specific events like a rising
// or falling edge on the external interrupt pin (INT0 or INT1).
//******************************************************************************************************************

//******************************************************************************************************************
// Example: EICRA = (EICRA & ~(1<<ISC00)) | (1<<ISC01);
// This operation configures the external interrupt sense control (ISC) for interrupt INT0 (External Interrupt Request 0).
// Specifically, it sets INT0 to trigger on a "falling edge" (when the signal transitions from high to low).
//
// The bits ISC01 and ISC00 in the EICRA register define how the external interrupt INT0 is triggered. The operation
// clears the bit ISC00 while setting ISC01 to 1, configuring INT0 to trigger when the pin transitions from high to low,
// i.e., on the falling edge.
//
// EICRA (External Interrupt Control Register A) controls how external interrupts INT0 and INT1 are triggered.
// - ISC01 = 1, ISC00 = 0 configures INT0 to trigger on falling edge (high to low transition).
//
// Before:  EICRA = b00000011  // Initial value with ISC01 = 1 and ISC00 = 1 (rising edge trigger for INT0)
// Operation: EICRA & ~(1<<ISC00) clears ISC00 bit (sets it to 0) while keeping ISC01 at 1. Then OR operation with (1<<ISC01) ensures ISC01 stays 1.
// After:   EICRA = b00000010  // The bit ISC00 is now cleared, configuring INT0 to trigger on the falling edge.
//
// This technique is used to configure the interrupt to trigger on the falling edge (transition from high to low),
// without changing the state of other control bits in the EICRA register.
//******************************************************************************************************************

#pragma once

#ifdef ATmega328_168

  // Define the clock speed for the microcontroller
  #define F_CPU 16000000L

  // Clear the timer count register (TCNT0)
  #define TIMER_TCNT_CLEAR TCNT0 = 0x00  // TCNT0 - Timer/Counter Register, clears the timer count

  // Set OCR0A to achieve a 100KHz clock frequency
  #define SET_OCROA_DIV OCR0A = 159;  // OCR0A – Output Compare Register A, 100KHz clock generation, 0x10011111

  // Configure Timer/Counter 0 for CTC mode and enable the clock source
  #define SET_TIMER_TCCROA TCCR0A |= (1 << WGM01);  // TCCR0A – Timer/Counter Control Register A, enable CTC mode (WGM01)
  #define SET_TIMER_TCCROB TCCR0B |= (1 << CS00);   // TCCR0B – Timer/Counter Control Register B, set clock source to I/O clock
                                                    //Waveform Generation Mode, Mode 2 CTC
  // Interrupt vector for timer compare match event
  #define CTC_TIMER_VECTOR TIMER0_COMPA_vect  //interrupt vector for match event, OCR0A comparison and Timer/Counter 0

  #include <stdint.h>
  #include <stdbool.h>
  #include <avr/io.h>
  #include <avr/interrupt.h>
  #include <avr/sfr_defs.h>
  #include <util/delay.h>

  // Global interrupt control settings
  #define GLOBAL_INTERRUPT_ENABLE SREG |= (1 << 7)    // Set the I-bit (bit 7) in the Status Register to enable global interrupts
  #define GLOBAL_INTERRUPT_DISABLE SREG &= ~(1 << 7)  // Clear the I-bit (bit 7) in the Status Register to disable global interrupts

  // Enable/Disable timer interrupts
  #define TIMER_INTERRUPT_ENABLE TIMSK0 |= (1 << OCIE0A)    // Enable interrupt on Timer0 Compare Match A
  #define TIMER_INTERRUPT_DISABLE TIMSK0 &= ~(1 << OCIE0A)  // Disable interrupt on Timer0 Compare Match A

  // Main pin configuration for input and output

  // Define the main pins as inputs
  #define PIN_DATA_INPUT DDRB &= ~(1 << DDB0)  // Set DDRB register to configure PINB0 as input
  #define PIN_WFCK_INPUT DDRB &= ~(1 << DDB1)  // Set DDRB register to configure PINB1 as input
  #define PIN_SQCK_INPUT DDRD &= ~(1 << DDD6)  // Set DDRB register to configure PINB6 as input
  #define PIN_SUBQ_INPUT DDRD &= ~(1 << DDD7)  // Set DDRB register to configure PINB7 as input

  // Enable pull-ups and set high on the main pins
  #define PIN_DATA_OUTPUT DDRB |= (1 << DDB0)  // Set DDRB register to configure PINB0 as output
  #define PIN_WFCK_OUTPUT DDRB |= (1 << DDB1)  // Set DDRB register to configure PINB1 as output

  // Define pull-ups and set high at the main pin
  #define PIN_DATA_SET PORTB |= (1 << PB0)  // Set PORTB register to make PINB0 high (enable pull-up)

  // Clear the main pins (set low)
  #define PIN_DATA_CLEAR PORTB &= ~(1 << PB0)  // Set PORTB register to make PINB0 low
  #define PIN_WFCK_CLEAR PORTB &= ~(1 << PB1)  // Set PORTB register to make PINB1 low

  // Read the state of the main input pins
  #define PIN_SQCK_READ (PIND & (1 << PIND6))  // Check if the value of PIND6 is high (1)
  #define PIN_SUBQ_READ (PIND & (1 << PIND7))  // Check if the value of PIND7 is high (1)
  #define PIN_WFCK_READ (PINB & (1 << PINB1))  // Check if the value of PIND1 is high (1)

  // LED pin handling (for indication)
  #ifdef LED_RUN
    #define PIN_LED_OUTPUT DDRB |= (1 << DDB5)  // Configure PINB5 as output (for LED)
    #define PIN_LED_ON PORTB |= (1 << PB5)      // Set PINB5 high (turn on LED)
    #define PIN_LED_OFF PORTB &= ~(1 << PB5)    // Set PINB5 low (turn off LED)
  #endif

  // Handling the BIOS patch
  #if defined(SCPH_102) || defined(SCPH_102_legacy) || defined(SCPH_100) || defined(SCPH_7000_9000) || defined(SCPH_5500) || defined(SCPH_3500_5000) || defined(SCPH_3000) || defined(SCPH_1000)

    // Clear the timer interrupt flag
    #define TIMER_TIFR_CLEAR TIFR0 |= (1 << OCF0A)  // Clear the Timer0 Compare Match A interrupt flag

    // Define input pins for the BIOS patch
    #define PIN_AX_INPUT DDRD &= ~(1 << DDD2)  // Set DDRD register to configure PIND2 as input
    #define PIN_DX_INPUT DDRD &= ~(1 << DDD4)  // Set DDRD register to configure PIND4 as input

    // Define output pins for the BIOS patch
    #define PIN_DX_OUTPUT DDRD |= (1 << DDD4)  // Set DDRD register to configure PIND4 as output

    // Set pull-ups high on output pins
    #define PIN_DX_SET PORTD |= (1 << PD4)  // Set PORTD register to make PIND4 high

    // Set pull-ups low on output pins
    #define PIN_DX_CLEAR PORTD &= ~(1 << PD4)  // Set PORTD register to make PIND4 low

    // Read the input pins for the BIOS patch
    #define PIN_AX_READ (PIND & (1 << PIND2))  // Read the state of PIND2

    // External interrupt configuration for BIOS patch
    #define PIN_AX_INTERRUPT_ENABLE EIMSK |= (1 << INT0)  // Enable external interrupt on INT0 (PINB2)
    #define PIN_AX_INTERRUPT_DISABLE EIMSK &= ~(1 << INT0)  // Disable external interrupt on INT0
    #define PIN_AX_INTERRUPT_RISING EICRA |= (1 << ISC01) | (1 << ISC00)  // Configure INT0 for rising edge trigger
    #define PIN_AX_INTERRUPT_FALLING (EICRA = (EICRA & ~(1 << ISC00)) | (1 << ISC01))  // Configure INT0 for falling edge trigger

    // Interrupt vectors for external interrupts
    #define PIN_AX_INTERRUPT_VECTOR INT0_vect  // Interrupt vector for INT0 (external interrupt)

    // Defin PIN_AY for HIGH_PATCH
    #if defined(SCPH_3000) || defined(SCPH_1000)
      #define PIN_AY_INPUT DDRD &= ~(1 << DDD3)  // Set DDRD register to configure PIND3 as input
      #define PIN_AY_READ (PIND & (1 << PIND3))  // Read the state of PIND3
      #define PIN_AY_INTERRUPT_ENABLE EIMSK |= (1 << INT1)  // Enable external interrupt on INT1 (PINB3)
      #define PIN_AY_INTERRUPT_DISABLE EIMSK &= ~(1 << INT1)  // Disable external interrupt on INT1
      #define PIN_AY_INTERRUPT_RISING EICRA |= (1 << ISC11) | (1 << ISC10)  // Configure INT1 for rising edge trigger
      #define PIN_AY_INTERRUPT_FALLING (EICRA = (EICRA & ~(1 << ISC10)) | (1 << ISC11))  // Configure INT1 for falling edge trigger
      #define PIN_AY_INTERRUPT_VECTOR INT1_vect  // Interrupt vector for INT1 (external interrupt)
    #endif

    // Handle switch input for BIOS patch
    #ifdef PATCH_SWITCH
      #define PIN_SWITCH_INPUT DDRD &= ~(1 << DDD5)  // Configure PIND5 as input for switch
      #define PIN_SWITCH_SET PORTD |= (1 << PD5)     // Set PIND5 high (enable pull-up)
      #define PIN_SWITCH_READ (PIND & (1 << PIND5))  // Read the state of PIND5 (switch input)
    #endif

  #endif

  #if defined(PSNEEDEBUG)
    #define DEBUG_PRINT(x)     Serial.print(x)
    #define DEBUG_PRINTHEX(x)  Serial.print(x, HEX)
    #define DEBUG_PRINTLN(x)   Serial.println(x)
    #define DEBUG_FLUSH        Serial.flush()
  #endif

#endif


#ifdef ATmega32U4_16U4

  #define F_CPU 16000000L
  #define TIMER_TCNT_CLEAR TCNT0 = 0x00;
  #define SET_OCROA_DIV OCR0A = 159;
  #define SET_TIMER_TCCROA TCCR0A |= (1 << WGM01);
  #define SET_TIMER_TCCROB TCCR0B |= (1 << CS00);
  #define CTC_TIMER_VECTOR TIMER0_COMPA_vect

  #include <stdint.h>
  #include <stdbool.h>
  #include <avr/io.h>
  #include <avr/interrupt.h>
  #include <avr/sfr_defs.h>
  #include <util/delay.h>

  // Globale interrupt seting
  #define GLOBAL_INTERRUPT_ENABLE SREG |= (1 << 7)
  #define GLOBAL_INTERRUPT_DISABLE SREG &= ~(1 << 7)

  #define TIMER_INTERRUPT_ENABLE TIMSK0 |= (1 << OCIE0A)
  #define TIMER_INTERRUPT_DISABLE TIMSK0 &= ~(1 << OCIE0A)

  // Handling the main pins

  // Main pins
  #define PIN_DATA_INPUT DDRB &= ~(1 << DDB4)
  #define PIN_WFCK_INPUT DDRB &= ~(1 << DDB5)
  #define PIN_SQCK_INPUT DDRD &= ~(1 << DDD7)
  #define PIN_SUBQ_INPUT DDRE &= ~(1 << DDE6)

  #define PIN_DATA_OUTPUT DDRB |= (1 << DDB4)
  #define PIN_WFCK_OUTPUT DDRB |= (1 << DDB5)

  // Define pull-ups and set high at the main pin
  #define PIN_DATA_SET PORTB |= (1 << PB4)
  // Define pull-ups set down at the main pin
  #define PIN_DATA_CLEAR PORTB &= ~(1 << PB4)
  #define PIN_WFCK_CLEAR PORTB &= ~(1 << PB5)
  // Read the main pins
  #define PIN_SQCK_READ (PIND & (1 << PIND7))
  #define PIN_SUBQ_READ (PINE & (1 << PINE6))
  #define PIN_WFCK_READ (PINB & (1 << PINB5))

  // Handling and use of the LED pin
  #ifdef LED_RUN
    #define PIN_LED_OUTPUT DDRB |= (1 << DDB6)
    #define PIN_LED_ON PORTB |= (1 << PB6)
    #define PIN_LED_OFF PORTB &= ~(1 << PB6)
  #endif

  // Handling the BIOS patch
  #if defined(SCPH_102) || defined(SCPH_102_legacy) || defined(SCPH_100) || defined(SCPH_7000_9000) || defined(SCPH_5500) || defined(SCPH_3500_5000) || defined(SCPH_3000) || defined(SCPH_1000)
  // Pins input
    #define PIN_AX_INPUT DDRD &= ~(1 << DDD1)
    #define PIN_AY_INPUT DDRD &= ~(1 << DDD0)
    #define PIN_DX_INPUT DDRD &= ~(1 << DDD4)
    // Pin output
    #define PIN_DX_OUTPUT DDRD |= (1 << DDD4)
    // Define pull-ups set high
    #define PIN_DX_SET PORTD |= (1 << PD4)
    // Define pull-ups set down
    #define PIN_DX_CLEAR PORTD &= ~(1 << PD4)
    // Read pins for BIOS patch
    #define PIN_AX_READ (PIND & (1 << PIND1))
    #define PIN_AY_READ (PIND & (1 << PIND0))
    // Handling and reading the switch pin for patch BIOS
    #ifdef PATCH_SWITCH
      #define PIN_SWITCH_INPUT DDRC &= ~(1 << DDC6)
      #define PIN_SWITCH_SET PORTC |= (1 << PC6)
      #define PIN_SWITCH_READ (PINC & (1 << PINC6))
    #endif

    // BIOS timer clear
    #define TIMER_TIFR_CLEAR TIFR0 |= (1 << OCF0A)

    // Handling the external interrupt
    #define PIN_AX_INTERRUPT_ENABLE EIMSK |= (1 << INT1)
    #define PIN_AY_INTERRUPT_ENABLE EIMSK |= (1 << INT0)

    #define PIN_AX_INTERRUPT_DISABLE EIMSK &= ~(1 << INT1)
    #define PIN_AY_INTERRUPT_DISABLE EIMSK &= ~(1 << INT0)

    #define PIN_AX_INTERRUPT_RISING EICRA |= (1 << ISC11) | (1 << ISC10)
    #define PIN_AY_INTERRUPT_RISING EICRA |= (1 << ISC01) | (1 << ISC00)

    #define PIN_AX_INTERRUPT_FALLING (EICRA = (EICRA & ~(1 << ISC10)) | (1 << ISC11))
    #define PIN_AY_INTERRUPT_FALLING (EICRA = (EICRA & ~(1 << ISC00)) | (1 << ISC01))

    #define PIN_AX_INTERRUPT_VECTOR INT1_vect
    #define PIN_AY_INTERRUPT_VECTOR INT0_vect

  #endif

#endif

#ifdef ATtiny85_45_25

  #define DF_CPU 8000000L
  #define TIMER_TCNT_CLEAR TCNT0 = 0x00;
  #define SET_OCROA_DIV OCR0A = 79;  //OCR0A – Output Compare Register A,100KHz
  #define SET_TIMER_TCCROA TCCR0A |= (1 << WGM01);
  #define SET_TIMER_TCCROB TCCR0B |= (1 << CS00);
  #define CTC_TIMER_VECTOR TIMER0_COMPA_vect



  #include <stdint.h>
  #include <stdbool.h>
  #include <avr/io.h>
  #include <avr/interrupt.h>
  #include <avr/sfr_defs.h>
  #include <util/delay.h>

  // Globale interrupt seting
  #define GLOBAL_INTERRUPT_ENABLE SREG |= (1 << 7)
  #define GLOBAL_INTERRUPT_DISABLE SREG &= ~(1 << 7)

  // Handling the main pins

  // Main pins input
  #define PIN_DATA_INPUT DDRB &= ~(1 << DDB2)
  #define PIN_WFCK_INPUT DDRB &= ~(1 << DDB4)
  #define PIN_SQCK_INPUT DDRB &= ~(1 << DDB0)
  #define PIN_SUBQ_INPUT DDRB &= ~(1 << DDB1)

  // Main pin output
  #define PIN_DATA_OUTPUT DDRB |= (1 << DDB2)
  #define PIN_WFCK_OUTPUT DDRB |= (1 << DDB4)

  // Define pull-ups and set high at the main pin
  #define PIN_DATA_SET PORTB |= (1 << PB2)

  // Define pull-ups set down at the main pin
  #define PIN_DATA_CLEAR PORTB &= ~(1 << PB2)
  #define PIN_WFCK_CLEAR PORTB &= ~(1 << PB4)

  // Read the main pins
  #define PIN_SQCK_READ (PINB & (1 << PINB0))
  #define PIN_SUBQ_READ (PINB & (1 << PINB1))
  #define PIN_WFCK_READ (PINB & (1 << PINB4))

  #define TIMER_INTERRUPT_ENABLE TIMSK |= (1 << OCIE0A)
  #define TIMER_INTERRUPT_DISABLE TIMSK &= ~(1 << OCIE0A)

  // Handling and use of the LED pin
  #ifdef LED_RUN
    #define PIN_LED_OUTPUT DDRB |= (1 << DDB3)
    #define PIN_LED_ON PORTB |= (1 << PB3)
    #define PIN_LED_OFF PORTB &= ~(1 << PB3)
  #endif

  #if !defined(SCPH_xxx1) && !defined(SCPH_xxx2) && && !defined(SCPH_xxx3) !defined(SCPH_103) && && !defined(SCPH_101) !defined(SCPH_xxxx) 
   #error "ATtiny85_45_25 Not compatible with BIOS patch"
  #endif

  #if defined(PSNEEDEBUG)
    #include <SoftwareSerial.h>
    SoftwareSerial mySerial(-1, 3); // RX, TX. (RX -1 = off)
    #define DEBUG_PRINT(x)     mySerial.print(x)
    #define DEBUG_PRINTHEX(x)  mySerial.print(x, HEX)
    #define DEBUG_PRINTLN(x)   mySerial.println(x)
    #define DEBUG_FLUSH        mySerial.flush()
  #endif

#endif

// *****************************************************************************************************************
// WARNING:
// The following code  is not functional as-is.
// *****************************************************************************************************************


#ifdef ATtiny88_48

  #define F_CPU 16000000L
  #define TIMER_TCNT_CLEAR TCNT0 = 0x00            //TCNT0 - Timer/Counter Register
  #define SET_OCROA_DIV OCR0A = 159;               //OCR0A – Output Compare Register A, 0x10011111, 100KHz
  #define SET_TIMER_TCCROA TCCR0A |= (1 << CTC0);  //TCCR0A – Timer/Counter Control Register A. turn on CTC mode, CTC0
  // On ATtiny88, TCCR0B doesn't exist — clock select bits (CS01, CS00) are in TCCR0A.
  // This sets the prescaler to 1, so the timer runs at full system clock (16 MHz).
  #define SET_TIMER_TCCROB TCCR0A |= (1 << CS01) | (1 << CS00)

  #define CTC_TIMER_VECTOR TIMER0_COMPA_vect  //interrupt vector for match event, OCR0A comparison and Timer/Counter 0


  #include <stdint.h>
  #include <stdbool.h>
  #include <avr/io.h>
  #include <avr/interrupt.h>
  #include <avr/sfr_defs.h>
  #include <util/delay.h>

  // Globale interrupt seting
  #define GLOBAL_INTERRUPT_ENABLE SREG |= (1 << 7)
  #define GLOBAL_INTERRUPT_DISABLE SREG &= ~(1 << 7)

  // Handling the main pins

  // Main pins input
  #define PIN_DATA_INPUT DDRB &= ~(1 << DDB0)
  #define PIN_WFCK_INPUT DDRB &= ~(1 << DDB1)  // Create a mask (1<<0) with the first bit at 1 b00000001 uses the ~ operator to perform a bit inversion b11111110,
  #define PIN_SQCK_INPUT DDRD &= ~(1 << DDD6)  // &= updates the DDRB register with the AND operator and the mask, DDRB bxxxxxxxx OR mask b11111110 = bxxxxxxx0
  #define PIN_SUBQ_INPUT DDRD &= ~(1 << DDD7)

  // Main pin output
  #define PIN_DATA_OUTPUT DDRB |= (1 << DDB0)  // Create a mask (1<<0) with the first bit at 1 b00000001,
  #define PIN_WFCK_OUTPUT DDRB |= (1 << DDB1)  // |= updates the DDRB register with the OR operator and the mask, DDRB bxxxxxxxx OR mask b00000001 = bxxxxxxx1

  // Define pull-ups and set high at the main pin
  #define PIN_DATA_SET PORTB |= (1 << PB0)  // Create a mask (1<<0) with the first bit at 1 b00000001, \
                                            // |= updates the PORTB register with the OR operator and the mask, PORTB bxxxxxxxx OR mask b00000001 = bxxxxxxx1

  // Define pull-ups set down at the main pin
  #define PIN_DATA_CLEAR PORTB &= ~(1 << PB0)  // Create a mask (1<<0) with the first bit at 1 b00000001 uses the ~ operator to perform a bit inversion b11111110,
  #define PIN_WFCK_CLEAR PORTB &= ~(1 << PB1)  // &= updates the DDRB register with the AND operator and the mask, DDRB bxxxxxxxx OR mask b11111110 = bxxxxxxx0

  // Read the main pins
  #define PIN_SQCK_READ (PIND & (1 << PIND6))  // Create a mask (1<<6) with the six bit at 1 b00100000,
  #define PIN_SUBQ_READ (PIND & (1 << PIND7))  // compare the PINB register and the mask with the AND operator, and returns the result, PINB bxx1xxxxx AND mask b00100000 = 1
  #define PIN_WFCK_READ (PINB & (1 << PINB1))

  // Handling and use of the LED pin
  #ifdef LED_RUN
    #define PIN_LED_OUTPUT DDRD |= (1 << DDD0)
    #define PIN_LED_ON PORTD |= (1 << PD0)
    #define PIN_LED_OFF PORTD &= ~(1 << PD0)
  #endif

  // Handling the BIOS patch
  #if defined(SCPH_102) || defined(SCPH_100) || defined(SCPH_7000_9000) || defined(SCPH_5500) || defined(SCPH_3500_5000) || defined(SCPH_3000) || defined(SCPH_1000)
    // BIOS interrupt seting
    #define TIMER_INTERRUPT_ENABLE TIMSK0 |= (1 << OCIE0A)
    #define TIMER_INTERRUPT_DISABLE TIMSK0 &= ~(1 << OCIE0A)

    // BIOS timer clear
    #define TIMER_TIFR_CLEAR TIFR0 |= (1 << OCF0A)

    // Pins input
    #define PIN_AX_INPUT DDRD &= ~(1 << DDD2)
    #define PIN_AY_INPUT DDRD &= ~(1 << DDD3)
    #define PIN_DX_INPUT DDRD &= ~(1 << DDD4)
    // Pin output
    #define PIN_DX_OUTPUT DDRD |= (1 << DDD4)
    // Define pull-ups set high
    #define PIN_DX_SET PORTD |= (1 << PD4)
    // Define pull-ups set down
    #define PIN_DX_CLEAR PORTD &= ~(1 << PD4)
    // Read pins for BIOS patch
    #define PIN_AX_READ (PIND & (1 << PIND2))
    #define PIN_AY_READ (PIND & (1 << PIND3))

    // Handling the external interrupt
    #define PIN_AX_INTERRUPT_ENABLE EIMSK |= (1 << INT0)
    #define PIN_AY_INTERRUPT_ENABLE EIMSK |= (1 << INT1)

    #define PIN_AX_INTERRUPT_DISABLE EIMSK &= ~(1 << INT0)
    #define PIN_AY_INTERRUPT_DISABLE EIMSK &= ~(1 << INT1)

    #define PIN_AX_INTERRUPT_RISING EICRA |= (1 << ISC01) | (1 << ISC00)
    #define PIN_AY_INTERRUPT_RISING EICRA |= (1 << ISC11) | (1 << ISC10)

    #define PIN_AX_INTERRUPT_FALLING (EICRA = (EICRA & ~(1 << ISC00)) | (1 << ISC01))
    #define PIN_AY_INTERRUPT_FALLING (EICRA = (EICRA & ~(1 << ISC10)) | (1 << ISC11))

    #define PIN_AX_INTERRUPT_VECTOR INT0_vect
    #define PIN_AY_INTERRUPT_VECTOR INT1_vect

    // Handling and reading the switch pin for patch BIOS
    #ifdef PATCH_SWITCH
      #define PIN_SWITCH_INPUT DDRD &= ~(1 << DDD5)
      #define PIN_SWITCH_SET PORTD |= (1 << PD5)
      #define PIN_SWITCH_READ (PIND & (1 << PIND5))
    #endif
  #endif

#endif

#ifdef ATtiny214_414

//#define SET_CTRLA
#define DF_CPU 20000000L
#define TIMER_TCNT_CLEAR TCA0.SINGLE.CNT = 0x00                           //TCNT0 - Timer/Counter Register
#define SET_OCROA_DIV TCA0.SINGLE.CMP0L = 100;                            //OCR0A – Output Compare Register A, 0x10011111, 100KHz
#define SET_TIMER_TCCROA TCA0.SINGLE.CTRLB |= (1 << TCA_SINGLE_WGM0);     //TCA_SINGLE_WGMODE_FRQ_gc    //TCCR0A – Timer/Counter Control Register A. turn on CTC mode, CTC0
#define SET_TIMER_TCCROB TCA0.SINGLE.CTRLA |= (1 << TCA_SINGLE_CLKSEL0);  //TCA_SINGLE_CLKSEL_DIV1_gc//TCCR0B – Timer/Counter Control Register B,  CS00: Clock Select,  clk I/O
                                                                          //Waveform Generation Mode, Mode 2 CTC
#define CTC_TIMER_VECTOR TCA0_OVF_vect                                    //TCA0_CMP0_vect            //interrupt vector for match event, OCR0A comparison and Timer/Counter 0


#include <stdint.h>
#include <stdbool.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/sfr_defs.h>
#include <util/delay.h>

// Globale interrupt seting
#define GLOBAL_INTERRUPT_ENABLE __asm__ __volatile__("sei" ::)   //CPU.SREG   |=  (1<<7)
#define GLOBAL_INTERRUPT_DISABLE __asm__ __volatile__("cli" ::)  //CPU.SREG   &= ~(1<<7)

// Handling the main pins

// Main pins input
#define PIN_DATA_INPUT PORTA.DIR = PIN2_bm
#define PIN_WFCK_INPUT PORTA.DIR = PIN1_bm  // Create a mask (1<<0) with the first bit at 1 b00000001 uses the ~ operator to perform a bit inversion b11111110,
#define PIN_SQCK_INPUT PORTA.DIR = PIN4_bm  // &= updates the DDRB register with the AND operator and the mask, DDRB bxxxxxxxx OR mask b11111110 = bxxxxxxx0
#define PIN_SUBQ_INPUT PORTA.DIR = PIN3_bm

// Main pin output
#define PIN_DATA_OUTPUT PORTA.DIR |= PIN2_bm  // Create a mask (1<<0) with the first bit at 1 b00000001,
#define PIN_WFCK_OUTPUT PORTA.DIR |= PIN1_bm  // |= updates the DDRB register with the OR operator and the mask, DDRB bxxxxxxxx OR mask b00000001 = bxxxxxxx1

// Define pull-ups and set high at the main pin
#define PIN_DATA_SET PORTA.OUT |= PIN2_bm  // Create a mask (1<<0) with the first bit at 1 b00000001,
                                           // |= updates the PORTB register with the OR operator and the mask, PORTB bxxxxxxxx OR mask b00000001 = bxxxxxxx1

// Define pull-ups set down at the main pin
#define PIN_DATA_CLEAR PORTA.OUT &= ~PIN2_bm  // Create a mask (1<<0) with the first bit at 1 b00000001 uses the ~ operator to perform a bit inversion b11111110,
#define PIN_WFCK_CLEAR PORTA.OUT &= ~PIN1_bm  // &= updates the DDRB register with the AND operator and the mask, DDRB bxxxxxxxx OR mask b11111110 = bxxxxxxx0

// Read the main pins
#define PIN_SQCK_READ PORTA.IN& PIN4_bm  // Create a mask (1<<6) with the six bit at 1 b00100000,
#define PIN_SUBQ_READ PORTA.IN& PIN3_bm  // compare the PINB register and the mask with the AND operator, and returns the result, PINB bxx1xxxxx AND mask b00100000 = 1
#define PIN_WFCK_READ PORTA.IN& PIN1_bm

// Handling and use of the LED pin
#define LED_RUN
#define PIN_LED_OUTPUT PORTB.DIR |= PIN2_bm
#define PIN_LED_ON PORTB.OUT |= PIN2_bm
#define PIN_LED_OFF PORTB.OUT &= ~PIN2_bm

// Handling the BIOS patch

// BIOS interrupt seting
#define TIMER_INTERRUPT_ENABLE TCA0.SPLIT.INTCTRL |= TCA_SINGLE_CMP0_bm
#define TIMER_INTERRUPT_DISABLE TCA0.SPLIT.INTCTRL &= ~TCA_SPLIT_HCMP0_bm

// BIOS timer clear
#define TIMER_TIFR_CLEAR TCA0.SPLIT.INTFLAGS = TCA_SPLIT_HCMP0_bm

// Pins input
#define PIN_AX_INPUT PORTB.DIR &= ~PIN3_bm
#define PIN_AY_INPUT PORTA.DIR &= ~PIN7_bm
#define PIN_DX_INPUT PORTA.DIR &= ~PIN6_bm
// Pin output
#define PIN_DX_OUTPUT PORTA.DIR |= PIN6_bm
// Define pull-ups set high
#define PIN_DX_SET PORTA.OUT |= PIN6_bm
// Define pull-ups set down
#define PIN_DX_CLEAR PORTA.OUT &= ~PIN6_bm
// Read pins for BIOS patch
#define PIN_AX_READ PORTB.IN& PIN3_bm
#define PIN_AY_READ PORTA.IN& PIN6_bm

// Handling the external interrupt
//#define PIN_AX_INTERRUPT_ENABLE     PORTB.PIN3CTRL  |=  (1<<INTn)
//#define PIN_AY_INTERRUPT_ENABLE     PORTA.PIN7CTRL  |=  (1<<INTn)

#define PIN_AX_INTERRUPT_DISABLE PORTB.PIN3CTRL = PORT_ISC_INTDISABLE_gc
#define PIN_AY_INTERRUPT_DISABLE PORTA.PIN7CTRL = PORT_ISC_INTDISABLE_gc

#define PIN_AX_INTERRUPT_RISING PORTB.PIN3CTRL = PORT_ISC_RISING_gc
#define PIN_AY_INTERRUPT_RISING PORTA.PIN7CTRL = PORT_ISC_RISING_gc

#define PIN_AX_INTERRUPT_FALLING PORTB.PIN3CTRL = PORT_ISC_FALLING_gc
#define PIN_AY_INTERRUPT_FALLING PORTA.PIN7CTRL = PORT_ISC_FALLING_gc

//#define PB3_INTERRUPT PORTB.INTFLAGS & PIN3_bm
//#define PA7_INTERRUPT PORTB.INTFLAGS & PIN7_bm

#define PIN_AX_INTERRUPT_VECTOR PORTB_PORT_vect
#define PIN_AY_INTERRUPT_VECTOR PORTA_PORT_vect

// Handling and reading the switch pin for patch BIOS
#define PIN_SWITCH_INPUT PORTA.DIR &= ~PIN5_bm
#define PIN_SWITCH_SET PORTA.OUT |= PIN5_bm
#define PIN_SWITCH_READ PORTA.IN& PIN5_bm

#endif

#ifdef LGT8F328P

#define F_CPU 32000000L
#define TIMER_TCNT_CLEAR TCNT0 = 0x00
#define SET_OCROA_DIV OCR0A = 319;
#define SET_TIMER_TCCROA TCCR0A |= (1 << WGM01);
#define SET_TIMER_TCCROB TCCR0B |= (1 << CS00);
#define CTC_TIMER_VECTOR TIMER0_COMPA_vect


#include <stdint.h>
#include <stdbool.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/sfr_defs.h>
#include <util/delay.h>

// Globale interrupt seting
#define GLOBAL_INTERRUPT_ENABLE SREG |= (1 << 7)
#define GLOBAL_INTERRUPT_DISABLE SREG &= ~(1 << 7)

// Handling the main pins

// Main pins input
#define PIN_DATA_INPUT DDRB &= ~(1 << DDB0)
#define PIN_WFCK_INPUT DDRB &= ~(1 << DDB1)
#define PIN_SQCK_INPUT DDRD &= ~(1 << DDD6)
#define PIN_SUBQ_INPUT DDRD &= ~(1 << DDD7)

// Main pin output
#define PIN_DATA_OUTPUT DDRB |= (1 << DDB0)
#define PIN_WFCK_OUTPUT DDRB |= (1 << DDB1)

// Define pull-ups and set high at the main pin
#define PIN_DATA_SET PORTB |= (1 << PB0)


// Define pull-ups set down at the main pin
#define PIN_DATA_CLEAR PORTB &= ~(1 << PB0)
#define PIN_WFCK_CLEAR PORTB &= ~(1 << PB1)

// Read the main pins
#define PIN_SQCK_READ (PIND & (1 << PIND6))
#define PIN_SUBQ_READ (PIND & (1 << PIND7))
#define PIN_WFCK_READ (PINB & (1 << PINB1))

// Handling and use of the LED pin
#define LED_RUN
#define PIN_LED_OUTPUT DDRB |= (1 << DDB5)
#define PIN_LED_ON PORTB |= (1 << PB5)
#define PIN_LED_OFF PORTB &= ~(1 << PB5)

// Handling the BIOS patch

// BIOS interrupt seting
#define TIMER_INTERRUPT_ENABLE TIMSK0 |= (1 << OCIE0A)
#define TIMER_INTERRUPT_DISABLE TIMSK0 &= ~(1 << OCIE0A)

// BIOS timer clear
#define TIMER_TIFR_CLEAR TIFR0 |= (1 << OCF0A)

// Pins input
#define PIN_AX_INPUT DDRD &= ~(1 << DDD2)
#define PIN_AY_INPUT DDRD &= ~(1 << DDD3)
#define PIN_DX_INPUT DDRD &= ~(1 << DDD4)
// Pin output
#define PIN_DX_OUTPUT DDRD |= (1 << DDD4)
// Define pull-ups set high
#define PIN_DX_SET PORTD |= (1 << PD4)
// Define pull-ups set down
#define PIN_DX_CLEAR PORTD &= ~(1 << PD4)
// Read pins for BIOS patch
#define PIN_AX_READ (PIND & (1 << PIND2))
#define PIN_AY_READ (PIND & (1 << PIND3))

// Handling the external interrupt
#define PIN_AX_INTERRUPT_ENABLE EIMSK |= (1 << INT0)
#define PIN_AY_INTERRUPT_ENABLE EIMSK |= (1 << INT1)

#define PIN_AX_INTERRUPT_DISABLE EIMSK &= ~(1 << INT0)
#define PIN_AY_INTERRUPT_DISABLE EIMSK &= ~(1 << INT1)

#define PIN_AX_INTERRUPT_RISING EICRA |= (1 << ISC01) | (1 << ISC00)
#define PIN_AY_INTERRUPT_RISING EICRA |= (1 << ISC11) | (1 << ISC10)

#define PIN_AX_INTERRUPT_FALLING (EICRA = (EICRA & ~(1 << ISC00)) | (1 << ISC01))
#define PIN_AY_INTERRUPT_FALLING (EICRA = (EICRA & ~(1 << ISC10)) | (1 << ISC11))

#define PIN_AX_INTERRUPT_VECTOR INT0_vect
#define PIN_AY_INTERRUPT_VECTOR INT1_vect

// Handling and reading the switch pin for patch BIOS
#define PIN_SWITCH_INPUT DDRD &= ~(1 << DDD5)
#define PIN_SWITCH_SET PORTD |= (1 << PD5)
#define PIN_SWITCH_READ (PIND & (1 << PIND5))

#endif

#ifdef CH32V003

#include "ch32v003.h"  // Inclure le fichier d'en-tête spécifique au microcontrôleur
#include <stdint.h>
#include <stdbool.h>

// Fréquence d'horloge
#define F_CPU 8000000L

// Configuration du timer pour une fréquence de 100 kHz
#define TIMER_TCNT_CLEAR TIM2_CNT = 0x00          // ok Effacer le compteur du Timer 2
#define SET_OCROA_DIV TIM2_ARR = 79               // not Définir la valeur de comparaison pour générer une interruption à 100 kHz
#define SET_TIMER_TCCROA TIM2_CR1 |= TIM_CR1_OPM  // notMettre le Timer en mode One Pulse (à adapter selon le mode souhaité)
#define SET_TIMER_TCCROB TIM2_PSC = 0             // ok Définir le prescaler à 0 pour une fréquence maximale

// Vecteur d'interruption pour le Timer 2
#define CTC_TIMER_VECTOR TIM2_UP_IRQHandler  // Remplacer par le vecteur d'interruption approprié

// Interruption globale
#define GLOBAL_INTERRUPT_ENABLE __enable_irq()
#define GLOBAL_INTERRUPT_DISABLE __disable_irq()

// Configuration des broches GPIO
#define PIN_DATA_INPUT GPIOA->INDR &= ~(GPIO_MODER_MODER0)
#define PIN_WFCK_INPUT GPIOA->INDR &= ~(GPIO_MODER_MODER1)
#define PIN_SQCK_INPUT GPIOA->INDR &= ~(GPIO_MODER_MODER6)
#define PIN_SUBQ_INPUT GPIOA->INDR &= ~(GPIO_MODER_MODER7)

#define PIN_DATA_OUTPUT GPIOA->OUTDR |= (GPIO_MODER_MODER0_0)
#define PIN_WFCK_OUTPUT GPIOA->OUTDR |= (GPIO_MODER_MODER1_0)

#define PIN_DATA_SET GPIOA->BSHR |= (GPIO_ODR_ODR_0)

#define PIN_DATA_CLEAR GPIOA->BRC &= ~(GPIO_ODR_ODR_0)
#define PIN_WFCK_CLEAR GPIOA->BRC &= ~(GPIO_ODR_ODR_1)

#define PIN_SQCK_READ (GPIOA->IDR & (GPIO_IDR_IDR_6))
#define PIN_SUBQ_READ (GPIOA->IDR & (GPIO_IDR_IDR_7))
#define PIN_WFCK_READ (GPIOA->IDR & (GPIO_IDR_IDR_1))

// Gestion de la broche LED
#define PIN_LED_OUTPUT GPIOA->MODER |= (GPIO_MODER_MODER5_0)
#define PIN_LED_ON GPIOA->ODR |= (GPIO_ODR_ODR_5)
#define PIN_LED_OFF GPIOA->ODR &= ~(GPIO_ODR_ODR_5)

// Gestion des interruptions du timer
#define TIMER_INTERRUPT_ENABLE TIM2_DIER |= (TIM_DIER_UIE)
#define TIMER_INTERRUPT_DISABLE TIM2_DIER &= ~(TIM_DIER_UIE)
#define TIMER_TIFR_CLEAR TIM2_SR &= ~(TIM_SR_UIF)

// Configuration des broches pour le BIOS
#define PIN_AX_INPUT GPIOA->MODER &= ~(GPIO_MODER_MODER2)AFIO_EXTICR
#define PIN_AY_INPUT GPIOA->MODER &= ~(GPIO_MODER_MODER3)
#define PIN_DX_INPUT GPIOA->MODER &= ~(GPIO_MODER_MODER4)

#define PIN_DX_OUTPUT GPIOA->MODER |= (GPIO_MODER_MODER4_0)

#define PIN_DX_SET GPIOA->ODR |= (GPIO_ODR_ODR_4)

#define PIN_DX_CLEAR GPIOA->ODR &= ~(GPIO_ODR_ODR_4)

#define PIN_AX_READ (GPIOA->IDR & (GPIO_IDR_IDR_2))
#define PIN_AY_READ (GPIOA->IDR & (GPIO_IDR_IDR_3))

// Gestion des interruptions externes
#define PIN_AX_INTERRUPT_ENABLE EXTI->IMR |= (EXTI_IMR_MR0)  //1<<EXTI_INTENR_MR0
#define PIN_AY_INTERRUPT_ENABLE EXTI->IMR |= (EXTI_IMR_MR1)

#define PIN_AX_INTERRUPT_DISABLE EXTI->IMR &= ~(EXTI_IMR_MR0)  //EXTI_INTENR
#define PIN_AY_INTERRUPT_DISABLE EXTI->IMR &= ~(EXTI_IMR_MR1)

#define PIN_AX_INTERRUPT_RISING EXTI->RTSR |= (EXTI_RTSR_TR0)  //EXTI_RTENR
#define PIN_AY_INTERRUPT_RISING EXTI->RTSR |= (EXTI_RTSR_TR1)

#define PIN_AX_INTERRUPT_FALLING EXTI->FTSR |= (EXTI_FTENR_MR0)  //EXTI_FTENR
#define PIN_AY_INTERRUPT_FALLING EXTI->FTSR |= (EXTI_FTENR_MR1)

#define PIN_AX_INTERRUPT_VECTOR EXTI0_IRQHandler
#define PIN_AY_INTERRUPT_VECTOR EXTI1_IRQHandler

// Gestion de la broche de commutation pour le BIOS
#define PIN_SWITCH_INPUT GPIOA->MODER &= ~(GPIO_MODER_MODER5)
#define PIN_SWITCH_SET GPIOA->ODR |= (GPIO_ODR_ODR_5)
#define PIN_SWITCH_READ (GPIOA->IDR & (GPIO_IDR_IDR_5))

#endif
